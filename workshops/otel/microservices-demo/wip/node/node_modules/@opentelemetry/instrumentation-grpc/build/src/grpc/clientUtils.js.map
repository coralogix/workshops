{"version":3,"file":"clientUtils.js","sourceRoot":"","sources":["../../../src/grpc/clientUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as grpcTypes from 'grpc';\nimport type * as events from 'events';\nimport { SendUnaryDataCallback, GrpcClientFunc } from './types';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { context, Span, SpanStatusCode, propagation } from '@opentelemetry/api';\nimport {\n  _grpcStatusCodeToSpanStatus,\n  _grpcStatusCodeToOpenTelemetryStatusCode,\n  findIndex,\n} from '../utils';\nimport { AttributeNames } from '../enums/AttributeNames';\nimport { metadataCaptureType } from '../internal-types';\nimport { GRPC_STATUS_CODE_OK } from '../status-code';\n\n/**\n * This method handles the client remote call\n */\nexport const makeGrpcClientRemoteCall = function (\n  metadataCapture: metadataCaptureType,\n  original: GrpcClientFunc,\n  args: any[],\n  metadata: grpcTypes.Metadata,\n  self: grpcTypes.Client\n) {\n  /**\n   * Patches a callback so that the current span for this trace is also ended\n   * when the callback is invoked.\n   */\n  function patchedCallback(\n    span: Span,\n    callback: SendUnaryDataCallback,\n    _metadata: grpcTypes.Metadata\n  ) {\n    const wrappedFn = (err: grpcTypes.ServiceError, res: any) => {\n      if (err) {\n        if (err.code) {\n          span.setStatus(_grpcStatusCodeToSpanStatus(err.code));\n          span.setAttribute(SemanticAttributes.RPC_GRPC_STATUS_CODE, err.code);\n        }\n        span.setAttributes({\n          [AttributeNames.GRPC_ERROR_NAME]: err.name,\n          [AttributeNames.GRPC_ERROR_MESSAGE]: err.message,\n        });\n      } else {\n        span.setStatus({ code: SpanStatusCode.UNSET });\n        span.setAttribute(\n          SemanticAttributes.RPC_GRPC_STATUS_CODE,\n          GRPC_STATUS_CODE_OK\n        );\n      }\n\n      span.end();\n      callback(err, res);\n    };\n    return context.bind(context.active(), wrappedFn);\n  }\n\n  return (span: Span) => {\n    if (!span) {\n      return original.apply(self, args);\n    }\n\n    // if unary or clientStream\n    if (!original.responseStream) {\n      const callbackFuncIndex = findIndex(args, arg => {\n        return typeof arg === 'function';\n      });\n      if (callbackFuncIndex !== -1) {\n        args[callbackFuncIndex] = patchedCallback(\n          span,\n          args[callbackFuncIndex],\n          metadata\n        );\n      }\n    }\n\n    span.addEvent('sent');\n\n    setSpanContext(metadata);\n    const call = original.apply(self, args);\n\n    (call as unknown as events.EventEmitter).on(\n      'metadata',\n      responseMetadata => {\n        metadataCapture.client.captureResponseMetadata(span, responseMetadata);\n      }\n    );\n\n    // if server stream or bidi\n    if (original.responseStream) {\n      // Both error and status events can be emitted\n      // the first one emitted set spanEnded to true\n      let spanEnded = false;\n      const endSpan = () => {\n        if (!spanEnded) {\n          span.end();\n          spanEnded = true;\n        }\n      };\n      context.bind(context.active(), call);\n      (call as unknown as events.EventEmitter).on(\n        'error',\n        (err: grpcTypes.ServiceError) => {\n          span.setStatus({\n            code: _grpcStatusCodeToOpenTelemetryStatusCode(err.code),\n            message: err.message,\n          });\n          span.setAttributes({\n            [AttributeNames.GRPC_ERROR_NAME]: err.name,\n            [AttributeNames.GRPC_ERROR_MESSAGE]: err.message,\n          });\n          if (err.code != null) {\n            span.setAttribute(\n              SemanticAttributes.RPC_GRPC_STATUS_CODE,\n              err.code\n            );\n          }\n          endSpan();\n        }\n      );\n\n      (call as unknown as events.EventEmitter).on(\n        'status',\n        (status: grpcTypes.StatusObject) => {\n          span.setStatus({ code: SpanStatusCode.UNSET });\n          span.setAttribute(\n            SemanticAttributes.RPC_GRPC_STATUS_CODE,\n            status.code\n          );\n          endSpan();\n        }\n      );\n    }\n    return call;\n  };\n};\n\nexport const getMetadata = function (\n  grpcClient: typeof grpcTypes,\n  original: GrpcClientFunc,\n  args: any[]\n): grpcTypes.Metadata {\n  let metadata: grpcTypes.Metadata;\n\n  // This finds an instance of Metadata among the arguments.\n  // A possible issue that could occur is if the 'options' parameter from\n  // the user contains an '_internal_repr' as well as a 'getMap' function,\n  // but this is an extremely rare case.\n  let metadataIndex = findIndex(args, (arg: any) => {\n    return (\n      arg &&\n      typeof arg === 'object' &&\n      arg._internal_repr &&\n      typeof arg.getMap === 'function'\n    );\n  });\n  if (metadataIndex === -1) {\n    metadata = new grpcClient.Metadata();\n    if (!original.requestStream) {\n      // unary or server stream\n      if (args.length === 0) {\n        // No argument (for the gRPC call) was provided, so we will have to\n        // provide one, since metadata cannot be the first argument.\n        // The internal representation of argument defaults to undefined\n        // in its non-presence.\n        // Note that we can't pass null instead of undefined because the\n        // serializer within gRPC doesn't accept it.\n        args.push(undefined);\n      }\n      metadataIndex = 1;\n    } else {\n      // client stream or bidi\n      metadataIndex = 0;\n    }\n    args.splice(metadataIndex, 0, metadata);\n  } else {\n    metadata = args[metadataIndex];\n  }\n  return metadata;\n};\n\nconst setSpanContext = function (metadata: grpcTypes.Metadata): void {\n  propagation.inject(context.active(), metadata, {\n    set: (metadata, k, v) => metadata.set(k, v as grpcTypes.MetadataValue),\n  });\n};\n"]}